# 3.2 Python风格对象
## 摘要
鸭子类型：按照预定行为实现对象所需的方法


## 对象表示形式
1. \__str__:str()
2. \__repr__:repr()
3. \__bytes__:bytes() -- 获取对象的字节序列表示形式
4. \__format__:format() str.format()
5. \__int__ :int()
6. \__float__:float()
7. \__complex__ :complex()

## 特殊方法：
 1. \__iter__:把类变成可迭代的对象，这样才能拆包

## classmethod
作用：
  - 定义操作类，而不是操作实例的方法
  - classmethod 最常见的用途是定义备选构造方法

staticmethod：
  - 静态方法就是普通的函数
  - 在类的定义体中，而不是在模块层定义


## 可散列
需实现方法：
1. \__hash__:
  - 应该返回一个整数
  - 还要考虑对象属性的散列值（ \__eq__ 方法也要使用）
  - 最好使用位运算符异或（ ^）混合各分量的散列值
2. \__eq__:
3. 对象不可变

## 私有属性
定义：
  - 两个前导下划线，尾部没有或最多有一个下划线命名的实例属性
  - Python 会把属性名存入实例的 \__dict__ 属性中，而且会在前面加上一个下划线和类名
  - Python 解释器不会对使用单个下划线的属性名做特殊处理

目的：避免意外访问，不能防止故意做错事

## \__slots__
实例属性：
  - 默认 Python 在实例中名为 \__dict__ 的字典里存储实例属性
  - \__slots__:让解释器在元组中存储实例属性，而不用字典
  - 继承自超类的 \__slots__ 属性没有效果,Python 只会使用各个类中定义的 slots 属性

\__slots特性:
  - 在类中定义 \__slots\__ 属性的目的是告诉解释器：“这个类中的所有实例属性都在这儿了！”Python 会在各个实例中使用类似元组的结构存储实例变量，从而避免使用消耗内存的 \__dict__ 属性
  - 如果要处理数百万个数值对象，应该使用 NumPy 数组
  - 在类中定义 \__slots\__ 属性之后，实例不能再有 \__slots__ 中所列名称之外的其他属性
  - 如果把 \__dict\__ 这个名称添加到 \__slots\__中，实例会在元组中保存各个实例的属性，此外还支持动态创建属性，这些属性存储在常规的 \__dict\__ 中

\__slots问题:
  - 每个子类都要定义 \__slots\__ 属性，因为解释器会忽略继承的 \__slots__ 属性
  - 实例只能拥有 \__slots\__ 中列出的属性，除非把 '\__dict__' 加入 \__slots\__ 中
  - 如果不把 '\__weakref\__' 加入 \__slots__，实例就不能作为弱引用的目标

\__weakref__:
  - 让对象支持弱引用
  - 用户定义的类中默认就有 \__weakref__ 属性
  - 如果类中定义了 \__slots\__ 属性，而且想把实例作为弱引用的目标，那么要把 '\__weakref\__'添加到 __slots__ 中


## 类属性覆盖

## 延伸阅读
### Python:
标准库

### blog:


### 实用工具  

### 书籍:

## 附注
